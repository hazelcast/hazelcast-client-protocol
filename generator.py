#!/usr/bin/env python3

import argparse
import time

from binary.util import test_output_directories, binary_output_directories
from binary_generator import save_test_files, save_binary_files, get_binary_templates
from util import *

start = time.time()

parser = argparse.ArgumentParser(description='Hazelcast Code Generator generates code of client protocol '
                                             'across languages.')

parser.add_argument('-r', '--root-dir',
                    dest='root_dir', action='store',
                    metavar='ROOT_DIRECTORY', default=None,
                    type=str, help='Root directory for the generated codecs (default value is ./output/[LANGUAGE])')

parser.add_argument('-l', '--lang',
                    dest='lang', action='store',
                    metavar='LANGUAGE', default='java',
                    choices=[lang.value for lang in SupportedLanguages],
                    type=str, help='Language to generate codecs for (default default is java)')

parser.add_argument('-p', '--protocol-definitions-path',
                    dest='proto_path', action='store',
                    metavar='PROTOCOL_DEFS_PATH', default=None,
                    type=str, help='Path of protocol definitions directory (default value is ./protocol-definitions)')

parser.add_argument('-o', '--output-dir',
                    dest='out_dir', action='store',
                    metavar='OUTPUT_DIRECTORY', default=None,
                    type=str, help='Path of the output directory relative to the '
                                   'root directory (default value is set according to the selected '
                                   'language)')

parser.add_argument('-n', '--namespace',
                    dest='namespace', action='store',
                    metavar='NAMESPACE', default=None,
                    type=str, help='Namespace for the generated codecs (default value is inferred from the '
                                   'selected language)')

parser.add_argument('-b', '--binary-output-dir',
                    dest='bin_out_dir', action='store',
                    metavar='BINARY_OUTPUT_DIRECTORY', default=None,
                    type=str, help='Path of the output directory relative to the '
                                   'root directory for the binary file.(default value is set according to the selected '
                                   'language)')

parser.add_argument('-t', '--test-output-dir',
                    dest='test_out_dir', action='store',
                    metavar='TEST_OUTPUT_DIRECTORY', default=None,
                    type=str, help='Path of the output directory relative to the '
                                   'root directory for the binary compatibility test files.(default value is '
                                   'set according to the selected language)')

parser.add_argument('--no-binary',
                    dest='no_binary', action='store_true', default=False,
                    help='Flag to signal that binary compatibility files and tests'
                         'should not be generated. These files are generated by default.')

parser.add_argument('--no-id-check',
                    dest='no_id_check', action='store_true', default=False,
                    help='Flag to signal that no sequential id check for service or method definitions '
                         'should be performed. These checks are done by default.')

args = parser.parse_args()
lang_str_arg = args.lang
root_dir_arg = args.root_dir
proto_path_arg = args.proto_path
out_dir_arg = args.out_dir
namespace_arg = args.namespace
test_out_dir_arg = args.test_out_dir
bin_out_dir_arg = args.bin_out_dir
no_binary_arg = args.no_binary
no_id_check = args.no_id_check

lang = SupportedLanguages[lang_str_arg.upper()]

curr_dir = os.path.dirname(os.path.realpath(__file__))

root_dir = root_dir_arg if root_dir_arg is not None else os.path.join(curr_dir, 'output', lang_str_arg)
relative_codec_output_dir = out_dir_arg if out_dir_arg is not None else codec_output_directories[lang]
codec_output_dir = os.path.join(root_dir, relative_codec_output_dir)

protocol_defs_path = proto_path_arg if proto_path_arg is not None else os.path.join(curr_dir, 'protocol-definitions')
custom_protocol_defs_path = os.path.join(protocol_defs_path, 'custom')

schema_path = os.path.join(curr_dir, 'schema', 'protocol-schema.json')
custom_codec_schema_path = os.path.join(curr_dir, 'schema', 'custom-codec-schema.json')

protocol_defs = load_services(protocol_defs_path)
custom_protocol_defs = None
if os.path.exists(custom_protocol_defs_path):
    custom_protocol_defs = load_services(custom_protocol_defs_path)

protocol_versions = sorted(get_protocol_versions(protocol_defs, custom_protocol_defs),
                           key=lambda ver: get_version_as_number(ver))
protocol_versions_as_numbers = list(map(get_version_as_number, protocol_versions))

protocol_defs = sorted(protocol_defs, key=lambda proto_def: proto_def['id'])
if not validate_services(protocol_defs, schema_path, no_id_check, protocol_versions_as_numbers):
    exit(-1)

if custom_protocol_defs is not None \
        and not validate_custom_protocol_definitions(custom_protocol_defs, custom_codec_schema_path,
                                                     protocol_versions_as_numbers):
    exit(-1)

print("Hazelcast Client Binary Protocol version %s" % (protocol_versions[-1]))
env = create_environment(lang, namespace_arg)

template_filename = env.get_template("codec-template.%s.j2" % lang_str_arg)

codec_template = env.get_template(template_filename)
generate_codecs(protocol_defs, codec_template, codec_output_dir, lang, env)
print('Generated codecs are at \'%s\'' % os.path.abspath(codec_output_dir))

if custom_protocol_defs is not None:
    custom_codec_template = env.get_template("custom-codec-template.%s.j2" % lang_str_arg)
    relative_custom_codec_output_dir = out_dir_arg if out_dir_arg is not None else custom_codec_output_directories[lang]
    custom_codec_output_dir = os.path.join(root_dir, relative_custom_codec_output_dir)
    generate_custom_codecs(custom_protocol_defs, custom_codec_template, custom_codec_output_dir, lang, env)
    print('Generated custom codecs are at \'%s\'' % custom_codec_output_dir)

if not no_binary_arg:
    relative_test_output_dir = test_out_dir_arg if test_out_dir_arg is not None else test_output_directories[lang]
    relative_binary_output_dir = bin_out_dir_arg if bin_out_dir_arg is not None else binary_output_directories[lang]
    test_output_dir = os.path.join(root_dir, relative_test_output_dir)
    binary_output_dir = os.path.join(root_dir, relative_binary_output_dir)

    error, binary_templates = get_binary_templates(lang)
    if binary_templates is not None:
        for version in protocol_versions:
            save_test_files(test_output_dir, lang, version, protocol_defs, binary_templates)
            save_binary_files(binary_output_dir, protocol_defs_path, version, protocol_defs)
        print('Generated binary compatibility files are at \'%s\'' % binary_output_dir)
        print('Generated binary compatibility tests are at \'%s\'' % test_output_dir)
    else:
        print('Binary compatibility test cannot be generated because the templates for the selected '
              'language cannot be loaded. Verify that the \'%s\' exists.' % error)

end = time.time()

print("Generator took: %d secs" % (end - start))
