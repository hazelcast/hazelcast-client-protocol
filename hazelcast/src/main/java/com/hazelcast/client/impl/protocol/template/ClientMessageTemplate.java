/*
 * Copyright (c) 2008-2017, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hazelcast.client.impl.protocol.template;

import com.hazelcast.annotation.GenerateCodec;
import com.hazelcast.annotation.Nullable;
import com.hazelcast.annotation.Request;
import com.hazelcast.annotation.Since;
import com.hazelcast.client.impl.protocol.constants.EventMessageConst;
import com.hazelcast.client.impl.protocol.constants.ResponseMessageConst;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;

import java.util.List;
import java.util.Map;

@GenerateCodec(id = TemplateConstants.CLIENT_TEMPLATE_ID, name = "Client", ns = "Hazelcast.Client.Protocol.Codec")
public interface ClientMessageTemplate {

    /**
     * @param username             Name of the user for authentication.
     * @param password             Password for the user.
     * @param uuid                 Unique string identifying the connected client uniquely. This string is generated by the owner member server
     *                             on initial connection. When the client connects to a non-owner member it sets this field on the request.
     * @param ownerUuid            Unique string identifying the server member uniquely.
     * @param isOwnerConnection    You must set this field to true while connecting to the owner member, otherwise set to false.
     * @param clientType           The type of the client. E.g. JAVA, CPP, CSHARP, etc.
     * @param serializationVersion client side supported version to inform server side
     * @param clientHazelcastVersion The Hazelcast version of the client. (e.g. 3.7.2)
     * @return Returns the address, uuid and owner uuid.
     */
    @Request(id = 2, retryable = true, response = ResponseMessageConst.AUTHENTICATION)
    Object authentication(String username, String password, @Nullable String uuid, @Nullable String ownerUuid,
                          boolean isOwnerConnection, String clientType, byte serializationVersion,
                          @Since (value = "1.3") String clientHazelcastVersion);

    /**
     * @param credentials          Secret byte array for authentication.
     * @param uuid                 Unique string identifying the connected client uniquely. This string is generated by the owner member server
     *                             on initial connection. When the client connects to a non-owner member it sets this field on the request.
     * @param ownerUuid            Unique string identifying the server member uniquely.
     * @param isOwnerConnection    You must set this field to true while connecting to the owner member, otherwise set to false.
     * @param clientType           The type of the client. E.g. JAVA, CPP, CSHARP, etc.
     * @param serializationVersion client side supported version to inform server side
     * @param clientHazelcastVersion The Hazelcast version of the client. (e.g. 3.7.2)
     * @return Returns the address, uuid and owner uuid.
     */

    @Request(id = 3, retryable = true, response = ResponseMessageConst.AUTHENTICATION)
    Object authenticationCustom(Data credentials, @Nullable String uuid, @Nullable String ownerUuid, boolean isOwnerConnection,
                                String clientType, byte serializationVersion,
                                @Since (value = "1.3") String clientHazelcastVersion);

    /**
     * @param localOnly if true only master node sends events, otherwise all registered nodes send all membership
     *                  changes.
     * @return Returns the registration id for the listener.
     */
    @Request(id = 4, retryable = false, response = ResponseMessageConst.STRING,
            event = {EventMessageConst.EVENT_MEMBER, EventMessageConst.EVENT_MEMBERLIST, EventMessageConst.EVENT_MEMBERATTRIBUTECHANGE})
    Object addMembershipListener(boolean localOnly);

    /**
     * @param name        The distributed object name for which the proxy is being created for.
     * @param serviceName The name of the service. Possible service names are:
     *                    "hz:impl:listService"
     *                    "hz:impl:queueService"
     *                    "hz:impl:setService"
     *                    "hz:impl:atomicLongService"
     *                    "hz:impl:atomicReferenceService"
     *                    "hz:impl:countDownLatchService"
     *                    "hz:impl:idGeneratorService"
     *                    "hz:impl:semaphoreService"
     *                    "hz:impl:executorService"
     *                    "hz:impl:mapService"
     *                    "hz:impl:mapReduceService"
     *                    "hz:impl:multiMapService"
     *                    "hz:impl:quorumService"
     *                    "hz:impl:replicatedMapService"
     *                    "hz:impl:ringbufferService"
     *                    "hz:core:proxyService"
     *                    "hz:impl:reliableTopicService"
     *                    "hz:impl:topicService"
     *                    "hz:core:txManagerService"
     *                    "hz:impl:xaService"
     */
    @Request(id = 5, retryable = false, response = ResponseMessageConst.VOID)
    void createProxy(String name, String serviceName, Address target);

    /**
     * @param name        The distributed object name for which the proxy is being destroyed for.
     * @param serviceName The name of the service. Possible service names are:
     *                    "hz:impl:listService"
     *                    "hz:impl:queueService"
     *                    "hz:impl:setService"
     *                    "hz:impl:atomicLongService"
     *                    "hz:impl:atomicReferenceService"
     *                    "hz:impl:countDownLatchService"
     *                    "hz:impl:idGeneratorService"
     *                    "hz:impl:semaphoreService"
     *                    "hz:impl:executorService"
     *                    "hz:impl:mapService"
     *                    "hz:impl:mapReduceService"
     *                    "hz:impl:multiMapService"
     *                    "hz:impl:quorumService"
     *                    "hz:impl:replicatedMapService"
     *                    "hz:impl:ringbufferService"
     *                    "hz:core:proxyService"
     *                    "hz:impl:reliableTopicService"
     *                    "hz:impl:topicService"
     *                    "hz:core:txManagerService"
     *                    "hz:impl:xaService"
     */

    @Request(id = 6, retryable = false, response = ResponseMessageConst.VOID)
    void destroyProxy(String name, String serviceName);

    /**
     * @return The partition list for each member address.
     */
    @Request(id = 8, retryable = false, response = ResponseMessageConst.PARTITIONS)
    Object getPartitions();

    @Request(id = 9, retryable = false, response = ResponseMessageConst.VOID)
    void removeAllListeners();

    /**
     * @param localOnly if true only node that has the partition sends the request, if false
     *                  sends all partition lost events.
     * @return The listener registration id.
     */
    @Request(id = 10, retryable = false, response = ResponseMessageConst.STRING, event = {EventMessageConst.EVENT_PARTITIONLOST})
    Object addPartitionLostListener(boolean localOnly);

    /**
     * @param registrationId The id assigned during the listener registration.
     * @return true if the listener existed and removed, false otherwise.
     */
    @Request(id = 11, retryable = true, response = ResponseMessageConst.BOOLEAN)
    Object removePartitionLostListener(String registrationId);

    /**
     * @return An array of distributed object info in the cluster.
     */
    @Request(id = 12, retryable = false, response = ResponseMessageConst.LIST_DISTRIBUTED_OBJECT)
    Object getDistributedObjects();

    /**
     * @param localOnly If set to true, the server adds the listener only to itself, otherwise the listener is is added for all
     *                  members in the cluster.
     * @return The registration id for the distributed object listener.
     */
    @Request(id = 13, retryable = false, response = ResponseMessageConst.STRING, event = {EventMessageConst.EVENT_DISTRIBUTEDOBJECT})
    Object addDistributedObjectListener(boolean localOnly);

    /**
     * @param registrationId The id assigned during the registration.
     * @return true if the listener existed and removed, false otherwise.
     */
    @Request(id = 14, retryable = true, response = ResponseMessageConst.BOOLEAN)
    Object removeDistributedObjectListener(String registrationId);

    @Request(id = 15, retryable = true, response = ResponseMessageConst.VOID)
    void ping();

    /**
     * The statistics is a String that is composed of key=value pairs separated by ',' . The following characters
     * ('=' '.' ',' '\') should be escaped in IMap and ICache names by the escape character ('\'). E.g. if the map name is
     * MyMap.First, it will be escaped as: MyMap\.First
     *
     * The statistics key identify the category and name of the statistics. It is formatted as:
     * mainCategory.subCategory.statisticName
     *
     * An e.g. Operating system committedVirtualMemorySize path would be: os.committedVirtualMemorySize
     *
     * The statistics key names can be one of the following (Used IMap named <StatIMapName> and ICache Named
     * <StatICacheName> and assuming that the near cache is configured):
     *
     * clientType
     * clusterConnectionTimestamp
     * credentials.principal
     * clientAddress
     * clientName
     * enterprise
     * lastStatisticsCollectionTime
     * nearcache.<StatIMapName>.creationTime
     * nearcache.<StatIMapName>.evictions
     * nearcache.<StatIMapName>.expirations
     * nearcache.<StatIMapName>.hits
     * nearcache.<StatIMapName>.lastPersistenceDuration
     * nearcache.<StatIMapName>.lastPersistenceFailure
     * nearcache.<StatIMapName>.lastPersistenceKeyCount
     * nearcache.<StatIMapName>.lastPersistenceTime
     * nearcache.<StatIMapName>.lastPersistenceWrittenBytes
     * nearcache.<StatIMapName>.misses
     * nearcache.<StatIMapName>.ownedEntryCount
     * nearcache.<StatIMapName>.ownedEntryMemoryCost
     * nearcache.hz/<StatICacheName>.creationTime
     * nearcache.hz/<StatICacheName>.evictions
     * nearcache.hz/<StatICacheName>.expirations
     * nearcache.hz/<StatICacheName>.hits
     * nearcache.hz/<StatICacheName>.lastPersistenceDuration
     * nearcache.hz/<StatICacheName>.lastPersistenceFailure
     * nearcache.hz/<StatICacheName>.lastPersistenceKeyCount
     * nearcache.hz/<StatICacheName>.lastPersistenceTime
     * nearcache.hz/<StatICacheName>.lastPersistenceWrittenBytes
     * nearcache.hz/<StatICacheName>.misses
     * nearcache.hz/<StatICacheName>.ownedEntryCount
     * nearcache.hz/<StatICacheName>.ownedEntryMemoryCost
     * os.committedVirtualMemorySize
     * os.freePhysicalMemorySize
     * os.freeSwapSpaceSize
     * os.maxFileDescriptorCount
     * os.openFileDescriptorCount
     * os.processCpuTime
     * os.systemLoadAverage
     * os.totalPhysicalMemorySize
     * os.totalSwapSpaceSize
     * runtime.availableProcessors
     * runtime.freeMemory
     * runtime.maxMemory
     * runtime.totalMemory
     * runtime.uptime
     * runtime.usedMemory
     * userExecutor.queueSize
     *
     * Not: Please observe that the name for the ICache appears to be the hazelcast instance name "hz" followed by "/" and
     * followed by the cache name provided which is StatICacheName.
     *
     * An example stats string (IMap name: v and ICache name: StatICacheName with near-cache enabled):
     *
     * lastStatisticsCollectionTime=1496047105664,enterprise=false,clientType=JAVA,clusterConnectionTimestamp=1496047047594,
     * clientAddress=127.0.0.1:5001,executionService.userExecutorQueueSize=0,runtime.maxMemory=1065025536,
     * os.freePhysicalMemorySize=1298280448,os.totalPhysicalMemorySize=17179869184,os.systemLoadAverage=291,
     * runtime.usedMemory=23234760,runtime.freeMemory=108820280,os.totalSwapSpaceSize=5368709120,runtime.availableProcessors=4,
     * runtime.uptime=62181,os.committedVirtualMemorySize=4144533504,os.maxFileDescriptorCount=10240,
     * runtime.totalMemory=132055040,os.processCpuTime=6320000000,os.openFileDescriptorCount=67,os.freeSwapSpaceSize=1102053376,
     * nearcache.StatIMapName.creationTime=1496047097216,nearcache.StatIMapName.evictions=0,nearcache.StatIMapName.hits=1,
     * nearcache.StatIMapName.lastPersistenceDuration=0,nearcache.StatIMapName.lastPersistenceKeyCount=0,
     * nearcache.StatIMapName.lastPersistenceTime=0,nearcache.StatIMapName.lastPersistenceWrittenBytes=0,
     * nearcache.StatIMapName.misses=1,nearcache.StatIMapName.ownedEntryCount=1,nearcache.StatIMapName.expirations=0,
     * nearcache.StatIMapName.ownedEntryMemoryCost=140,nearcache.hz/StatICacheName.creationTime=1496047103690,
     * nearcache.hz/StatICacheName.evictions=0,nearcache.hz/StatICacheName.hits=1,
     * nearcache.hz/StatICacheName.lastPersistenceDuration=0,nearcache.hz/StatICacheName.lastPersistenceKeyCount=0,
     * nearcache.hz/StatICacheName.lastPersistenceTime=0,nearcache.hz/StatICacheName.lastPersistenceWrittenBytes=0,
     * nearcache.hz/StatICacheName.misses=1,nearcache.hz/StatICacheName.ownedEntryCount=1,
     * nearcache.hz/StatICacheName.expirations=0,nearcache.hz/StatICacheName.ownedEntryMemoryCost=140
     *
     *
     * @param stats The key=value pairs separated by the ',' character
     */
    @Request(id = 16, retryable = false, response = ResponseMessageConst.VOID)
    @Since(value = "1.5")
    void statistics(String stats);

    /**
     * Deploys the list of classes to cluster
     * Each item is a Map.Entry<String, byte[]> in the list.
     * key of entry is full class name, and byte[] is the class definition.
     *
     * @param classDefinitions list of class definitions
     */
    @Request(id = 17, retryable = false, response = ResponseMessageConst.VOID)
    @Since(value = "1.5")
    void deployClasses(List<Map.Entry<String, byte[]>> classDefinitions);
}
